# Обзор предметной области

Для программ, относящихся к стеку разработки программного обеспечения,
критически важно гарантировать отсутствие как можно большего числа возможных
ошибок, ведь цена ошибки в этой области чрезвычайно высока. В настоящее время
уже существуют различные проекты, направленные на избежание ошибок в
программах стека разработки.

В данной главе представлены обзор существующих проектов и введение в
кодогенерацию и компоновку программ.

## От исходного кода к исполнению на CPU

Готовый исходный код проходит через несколько стадий трансляции перед
непосредственным исполнением на CPU:

*   последовательная трансляция в промежуточные представления;
*   трансляция в ассемблер с выбором ABI;
*   трансляция из языка ассемблера в машинный код;
*   упаковка машинного кода в объектные файлы;
*   отображение объектных файлов в память;
*   линковка загруженного в память кода.

На каждой стадии могут производиться некоторые оптимизации кода. Процесс
трансляции и оптимизации кода отражен на следующей диаграмме:

**TODO: вставить диаграмму без подписей**

**TODO: странслировать происходящее в презенташке сюда**

В настоящее время существуют различные проекты, доказывающие корректность
производимых на различных уровнях оптимизаций.

## Какая-то теория по линковке

Определим используемые в дальнейшем термины.

_Язык ассемблера_ — машинно-ориентированный язык, предназначенный для
представления в удобочитаемой форме программ, записанных в машинном коде.
Каждая команда языка ассемблера соответствует какой-либо команде
исполнителя. Для краткости будем называть язык ассемблера _ассемблером_.

_SSA-представление (static single assignment form)_ — промежуточное
представление кода, в котором каждой переменной значение присваивается не
более одного раза.

_Компоновка (линковка)_ — сборка исполняемого файла из нескольких объектных
файлов, в процессе которой происходит проставление необходимых ссылок на
внешние функции и переменные. При _статической_ линковке код всех исходных
объектных файлов включается в результирующий файл с уже заполненными
ссылками на переменные и функции. При _динамической_ линковке в объектные
файлы добавляется только необходимая метаинформация и, возможно,
дополнительные фрагменты исходного кода, а непосредственное заполнение
ссылок производится при загрузке программы и библиотек _динамическим
загрузчиком_.

К дополнительным фрагментам исходного кода, добавляемых при динамической
линковке, относятся таблицы _GOT (global offset table)_ и _PLT (procedure
linkage table)_.

_Простой динамической линковкой_ будем называть динамическую линковку, при
которой вызовы внешних функций заменяются вызовом соответствующих им
элементов PLT, а сам элемент PLT состоит из одной инструкции: indirect
`jmp` на соответствующий элемент GOT.

## Software Foundations

Software Foundations [@sf] — курс по математическим основам надежного
программного обеспечения. Покрывает основные понятия логики, доказательство
теорем с помощью Coq[@coq], функциональное программирование и статические
системы типов, не требуя при этом предварительного углубленного изучения
логики или языков программирования.

Отличительной особенностью этого курса является то, что он полностью
формализован и ориентирован на чтение и выполнение упражнений внутри
интерактивной сессии Coq.

## Iron Lambda

Iron Lambda [@ironlambda] — набор доказательств на Coq для функциональных
языков программирования различной сложности. Покрывает несколько
распространенных систем типов. В их число входят просто типизированное
лямбда-исчисление, SystemF и некоторые их расширения.

## CompCert

CompCert [@compcert] — исследовательский проект, направленный на разработку
формально верифицированных компиляторов, применимых для встраиваемого
программного обеспечения. Такие компиляторы предоставляют machine-checked
доказательства того, что генерируемый ими код имеет ту же семантику, что и
исходный код.

Основным результатом этого проекта является верифицированный компилятор
языка C, покрывающий почти весь стандарт ISO C90 и генерирующий эффективный
код для архитектур PowerPC, ARM и x86.

## VeLLVM

VeLLVM (Verified LLVM) [@vellvm] представляет собой фреймворк для
доказательства утверждений о программах, записанных в промежуточном
представлении LLVM. Содержит формализацию промежуточного представления
LLVM, его системы типов и свойств его SSA-представления.

## Typed Assembly Language

В статье [@tal] описаны статически типизированный язык ассемблера (TAL) и
сохраняющая типы трансляция в него из SystemF. TAL основан на обычном RISC
ассемблере, но его система типов обеспечивает поддержку языковых
абстракций высокого уровня (например, замыкания, кортежи и пользовательские
типы данных). При этом TAL не накладывает почти никаких ограничений на
оптимизации более низкого уровня, таких как аллокация регистров и выбор
инструкций.

Типизированный ассемблер можно применять для написания верифицированных
компиляторов и доказательства различных теорем про **TODO**.

## Возможный путь решения

Поставленную задачу **TODO: а где она была сформулирована?** планируется
решить, формализовав типизированный ассемблер, содержащий необходимое для
реализации простой динамической линковки подмножество инструкций ассемблера
x86-64, с помощью реализованного ассемблера формализовать подмножество ABI,
касающееся линковки, ввести понятие эквивалентности блоков кода и доказать
требуемую эквивалентность.

## Выводы по главе

В данной главе было представлено введение в кодогенерацию и линковку, а так
же был дан краткий обзор существующих проектов, покрывающих различные
уровни процесса трансляции исходного кода в исполняемый машинный код.
