%   Формальное доказательство эквивалентности программ, скомпилированных в ABI
    со статическим и динамическим связыванием
%   Пьянкова Ю. А.\
    Научный руководитель: Малаховски Я. М.
%   29 мая 2015

---

# Введение

* Цена ошибки в программе пропорциональна:
    * частоте проявления,
    * сложности поиска,
    * сложности исправления.
* Вполне вероятно, что на данном этапе развития технологий не про все
  программы экономически целесообразно доказывать их корректность.
* Однако про инструменты разработки ПО уже давно целесообразно,
  поскольку сложность поиска и исправления ошибок в них чрезвычайно
  высоки, а многие полезные теоремы уже доказаны.

---

# Существующие решения

* Software Foundations
    * учебник с формализациями простых исчислений и доказательств о них на Coq
* Iron Lambda
    * продолжение Software Foundations на реально использующиеся исчисления
    * доказаны все стандартные теоремы про все стандартные лямбда-исчисления
    * реально используется в компиляторе Disciple
* CompCert
    * компилятор подмножества C с доказанно корректными оптимизациями
* VeLLVM
    * транслятор SSA ассемблера с доказанно корректными оптимизациями

---

![](diagram.png)

---

* S — изначальный язык программирования
* I — промежуточные языки, в которые транслируется код
* ASM — язык ассемблера
* opcode — машинный код
* .o — скомпилированные файлы с исполняемым кодом
* map mem — код, загруженный в память
* ld mem — пролинкованный код в памяти

---

# CompCert

![](compcert.png)

---

# VeLLVM

![](vellvm.png)

---

# Можно только верить

![](faith.png)

---

# Верифицированные менеджеры памяти

![](memory.png)

---

# Можно доказать

![](ld.png)

---

# Цель работы

%TODO перепилить

* Разработка метода для формальной верификации компоновщиков программ.
* Проблемы:
    * программы соответствуют некоторому ABI и надо доказывать сохранение семантики компоновщиком с точностью до заданного ABI;
    % TODO
    * ленивая динамическая линковка страшна.
* Почему задача решаема:
    * не нужна работа с динамической памятью, что не требует решения больших открытых проблем;
    * статическая линковка проста и приятна.

---

# PROFIT

%TODO перепилить

* Углубится стек доказанного про тулчейны разработки.
* Можно будет ловить ошибки в кодогенераторах и компоновщиках:
    * глупые баги (например, обращение к чужому GOT, когда забыли PC stub);
    * нарушение ABI (это не всегда понятно как описать просто типизацией).
* В перспективе можно будет даже доказывать какие-то полезные утверждения:
    * например, безопасность по отношению к setuid бинарникам.

---

# Результаты

*   Формализовано подмножество ассемблера x86_64 на базовых блоках со стеком и
    типизированной статической памятью

    * подмножество необходимое для описания элементов PLT
    * арифметические (TODO?) инструкции

*   В этом фреймворке формализовано подмножество ABI, касающееся компоновки
    со статическим и динамическим связыванием

*   TODO meta assembler

---

# Результаты

*   Доказана (интенсиональная) эквивалентность состояний исполнителя в момент
    непосредственного вызова функции и после исполнения непрямого `jmp` по
    указателю на тело функции
*   Доказана (интенсиональная) эквивалентность состояний исполнителя в момент
    непосредственного вызова функции и после исполнения соответствующего этой
    функции элемента PLT при условии корректно заполненного GOT
*   Доказана внешняя эквивалентность (эквивалентность вызовов) некоторой
    функции и соответствующего ей элемента PLT при условии корректно
    заполненного GOT

---

\Huge Вопросы?
