%   Формальное доказательство эквивалентности программ, скомпилированных в ABI
    со статическим и динамическим связыванием
%   Пьянкова Ю. А.\
    Научный руководитель: Малаховски Я. М.
%   13 мая 2015

---

# Введение

* Цена ошибки в программе пропорциональна:
    * частоте проявления,
    * сложности поиска,
    * сложности исправления.
* Вполне вероятно, что на данном этапе развития технологий не про все
  программы экономически целесообразно доказывать их корректность.
* Однако про инструменты разработки ПО уже давно целесообразно,
  поскольку сложность поиска и исправления ошибок в них чрезвычайно
  высоки, а многие полезные теоремы уже доказаны.

---

# Что есть (1)

* Software Foundations: подходит только для обучения.
* Iron Lambda: реально используется в компиляторе Disciple.
* CompCert: целый компилятор C с некоторыми оптимизациями.
* VeLLVM: целый кодогенератор с некоторыми оптимизациями.

---

# Что есть (2)

* В Iron Lambda передоказаны все теоремы про лямбда-исчисление.
* В CompCert и VeLLVM доказана корректность некоторых преобразований (оптимизаций).

---

# Чего у них нет

* Все предполагают, что ниже них по стеку все корректно.
* А что, если нет?

---

# Почему у них этого нет

* С выбором инструкций, действительно, непонятно что можно делать. В него, видимо, надо просто поверить.
* Верифицированные менеджеры памяти — это большая открытая проблема.
* Зато есть целая подсистема компоновки программ, которую никто не верифицирует. А её можно бы и верифицировать.

---

# Цель работы

* Разработка метода для формальной верификации компоновщиков программ.
* Проблемы:
    * у программ есть ABI и надо доказывать сохранение семантики компоновщиком с точностью до заданного ABI;
    * ленивая динамическая линковка страшна.
* Почему задача решаема:
    * не нужна работа с динамической памятью, что не требует решения больших открытых проблем;
    * статическая линковка проста и приятна.

---

# PROFIT

* Углубится стек доказанного про тулчейны разработки.
* Можно будет ловить ошибки в кодогенераторах и компоновщиках:
    * глупые баги (например, обращение к чужому GOT, когда забыли PC stub);
    * нарушение ABI (это не всегда понятно как описать просто типизацией).
* В перспективе можно будет даже доказывать какие-то полезные утверждения:
    * например, безопасность по отношению к setuid бинарникам.

---

# Что делается

Тут должно было быть 76Kb кода на Agda, но мы решили вас от него избавить.

---

\Huge Вопросы?
