%   Формальное доказательство эквивалентности программ, скомпилированных в ABI
    со статическим и динамическим связыванием
%   Пьянкова Ю. А.\
    Научный руководитель: Малаховски Я. М.
%   29 мая 2015

---

# Введение

* Цена ошибки в программе пропорциональна:
    * частоте проявления,
    * сложности поиска,
    * сложности исправления.
* Вполне вероятно, что на данном этапе развития технологий не про все
  программы экономически целесообразно доказывать их корректность.
* Однако про инструменты разработки ПО уже давно целесообразно,
  поскольку сложность поиска и исправления ошибок в них чрезвычайно
  высоки, а многие полезные теоремы уже доказаны.

---

![](../images/diagram.png)

---

* S — изначальный язык программирования
* I — промежуточные языки, в которые транслируется код
* ASM — язык ассемблера
* opcode — машинный код
* .o — скомпилированные файлы с исполняемым кодом
* map mem — код, загруженный в память
* ld mem — пролинкованный код в памяти

---

![](../images/idealworld.png)

В идеальном мире диаграмма коммутативна: $t \circ o = e \circ t$

---

**TODO: теорема из алгебры о том, что если соприкасаются коммутативные
диаграммы, то составная диаграмма коммутативна**

---

# Идеальный компилятор

![](../images/idealcompiler.png)

---

![](../images/faith.png)

---

* Выбор опкодов:
    * можно верифицировать, если иметь модель CPU;
* Генерация объектных файлов:
    * **TODO**
* Загрузка объектных файлов в память:
    * верифицированные менеджеры памяти — большая открытая проблема;
* Техпроцесс:
    * можно только поверить.

---

# Существующие решения

* Software Foundations
    * учебник с формализациями простых исчислений и доказательств о них на Coq
* Iron Lambda
    * продолжение Software Foundations на реально использующиеся исчисления
    * доказаны все стандартные теоремы про все стандартные лямбда-исчисления
    * реально используется в компиляторе Disciple
* CompCert
    * компилятор подмножества C с доказанно корректными оптимизациями
* VeLLVM
    * транслятор SSA ассемблера с доказанно корректными оптимизациями

---

# CompCert

![](../images/compcert.png)

---

# VeLLVM

![](../images/vellvm.png)

---

# Цель работы

![](../images/ld.png)

---

# Цель работы

* Почему задача решаема:
    *   мы верим:
        *   производителям CPU;
        *   соответствию ассемблера спецификации;
        *   разработчикам ядра ОС;
        *   корректности работы с объектными файлами;
    *   не нужна работа с динамической памятью, что не требует решения
        больших открытых проблем.
* Проблемы:
    *   программы соответствуют некоторому ABI, и надо доказывать сохранение
        семантики компоновщиком с точностью до заданного ABI;
    *   в области формальных доказательств существуют серьезные проблемы с
        переиспользованием доказательств для слегка измененных определений.

---

# Основные сущности и типы

**TODO: определения RegTypes, DataType, DataStackType и CallStackType**

**TODO: определения RegType и Type**

---

# Инструкции

**TODO: сигнатура управляющей инструкции**

**TODO: сигнатура обычной инструкции**

---

# Мета-ассемблер

*   При небольшом изменении основных определений все доказательства приходится
    менять
*   Общую для всех языков ассемблера часть можно определить независимо от
    конкретного языка ассемблера

**TODO: сигнатура Block и exec-block (полные, с учетом параметров модуля)**

---

# Мета-ассемблер

*   Блок $A$ в состоянии исполнителя $S_A$ и блок $B$ в состоянии
    исполнителя $S_B$ считаются эквивалентными, если конструктивно
    существует такой блок $C$ в состоянии исполнителя $S_C$, что исполнение
    и $A$ из состояния $S_A$, и $B$ из состояния $S_B$ приводят к $C$ и
    состоянию $S_C$

**TODO: определение BlockEq**

---

# Мета-ассемблер

*   Определения, относящиеся к мета-ассемблеру, можно получать по
    минимальному описанию конкретного языка ассемблера:

**TODO: 2Meta.exec-block**

---

**TODO: возможно, тут должно быть определение различных инструкций из
модуля AMD64**

---

# Линковка

*   При динамической линковке в память добавляются таблицы GOT и PLT:

**TODO: pltize**

*   Элемент таблицы PLT выглядит следующим образом:

**TODO: plt-stub**

---

# Доказательства

*   Состояние исполнителя в момент непосредственного вызова функции
    эквивалентно состоянию исполнителя после исполнения непрямого `jmp`
    по указателю на ее тело:

**TODO: exec-ijmp**

---

# Доказательства

*   Состояние исполнителя в момент непосредственного вызова функции
    эквивалентно состоянию исполнителя после исполнения соответствующего
    этой функции элемента PLT при условии корректно заполненного GOT:

**TODO: exec-plt**

---

# Доказательства

*   При корректно заполненном GOT верна внешняя эквивалентность блока PLT,
    использующего соответствующий функции элемент GOT, и самой функции:

**TODO: сигнатура последнего доказательства**

---

# Эквивалентность программ

*   Неформально: две программы можно считать эквивалентными, если для
    любого корректного начального состояния исполнителя результаты
    выполнения программ одинаковы
*   Для каждой программы $A$ задан стартовый блок $B_A$
*   Две программы $A$ и $B$ считаются эквивалентными, если для любого
    корректного состояния исполнителя $S_{start}$ эквивалентны $B_A$ в
    состоянии $S_{start}$ и $B_B$ в состоянии $S_{start}$

---

# Предположения

*   Если для любого состояния $S$ блок $A$ эквивалентен блоку $B$, то
    замена блока $A$ на блок $B$ в программе не влияет на результат исполнения
*   Добавление новых элементов в память с соответствующей заменой
    указателей не влияет на результат исполнения

---

# Эквивалентность программ, слинкованных статически и динамически

*   Эквивалентны:
    *   статически слинкованная программа;
    *   статически слинкованная программа с добавленными таблицами GOT и PLT;
    *   статически слинкованная программа с добавленными таблицами GOT и PLT с
        заменой вызовов функций на вызовы соответствующих элементов PLT.
*   Последний пункт после загрузки в память структурно эквивалентен
    динамически слинкованной программе с точностью до перестановки данных,
    расположенных в памяти.

---

# Результаты

*   Реализован фреймворк (мета-ассемблер), обобщающий определения основных
    сущностей и эквивалентности блоков для различных языков ассемблера.

*   Формализовано подмножество ассемблера x86_64 на базовых блоках со стеком и
    типизированной статической памятью:

    * подмножество, необходимое для описания элементов PLT;
    * основные управляющие инструкции, совершающие безусловные переходы;
    * загрузка значения из памяти в регистр;
    * основные инструкции, работающие со стеком данных.

*   Формализовано подмножество ABI, касающееся компоновки со статическим и
    динамическим связыванием.

---

# Результаты

*   Доказана (интенсиональная) эквивалентность состояний исполнителя в момент
    непосредственного вызова функции и после исполнения непрямого `jmp` по
    указателю на тело функции
*   Доказана (интенсиональная) эквивалентность состояний исполнителя в момент
    непосредственного вызова функции и после исполнения соответствующего этой
    функции элемента PLT при условии корректно заполненного GOT
*   Доказана внешняя эквивалентность (эквивалентность вызовов) некоторой
    функции и соответствующего ей элемента PLT при условии корректно
    заполненного GOT
*   В указанных выше предположениях доказана эквивалентность статически и
    динамически слинкованных программ

---

# PROFIT

%TODO перепилить (пока непонятно как)

* Углубится стек доказанного про тулчейны разработки.
* Можно будет ловить ошибки в кодогенераторах и компоновщиках:
    * глупые баги (например, обращение к чужому GOT, когда забыли PC stub);
    * нарушение ABI (это не всегда понятно как описать просто типизацией).
* В перспективе можно будет даже доказывать какие-то полезные утверждения:
    * например, безопасность по отношению к setuid бинарникам.

---

\Huge Вопросы?
